-- Enable RLS but allow public access for this demo (since we use Anon Key in backend without Service Role)
-- ideally we should use Service Role Key for backend, but we only have Anon Key.
-- So we will create policies to allow Anon key to do everything.

-- Users Table
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    username TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    role TEXT NOT NULL,
    "isActive" BOOLEAN DEFAULT false
);

ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all access to users" ON users
FOR ALL
USING (true)
WITH CHECK (true);

-- User Project Access Table
CREATE TABLE IF NOT EXISTS user_project_access (
    id SERIAL PRIMARY KEY,
    "userId" INTEGER REFERENCES users(id) ON DELETE CASCADE,
    "projectId" TEXT REFERENCES projects(id) ON DELETE CASCADE,
    UNIQUE("userId", "projectId")
);

ALTER TABLE user_project_access ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all access to user_project_access" ON user_project_access
FOR ALL
USING (true)
WITH CHECK (true);

-- Projects Table
CREATE TABLE IF NOT EXISTS projects (
    id TEXT PRIMARY KEY,
    data JSONB
);

ALTER TABLE projects ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all access to projects" ON projects
FOR ALL
USING (true)
WITH CHECK (true);

-- Goals Table
CREATE TABLE IF NOT EXISTS goals (
    id TEXT PRIMARY KEY,
    "projectId" TEXT REFERENCES projects(id) ON DELETE CASCADE,
    data JSONB
);

ALTER TABLE goals ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all access to goals" ON goals
FOR ALL
USING (true)
WITH CHECK (true);

-- Scopes Table
CREATE TABLE IF NOT EXISTS scopes (
    id TEXT PRIMARY KEY,
    "goalId" TEXT REFERENCES goals(id) ON DELETE CASCADE,
    data JSONB
);

ALTER TABLE scopes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all access to scopes" ON scopes
FOR ALL
USING (true)
WITH CHECK (true);

-- Deliverables Table
CREATE TABLE IF NOT EXISTS deliverables (
    id TEXT PRIMARY KEY,
    "scopeId" TEXT, -- Optional FK, as we might have many-to-many logic in app, but simple link here
    data JSONB
);

ALTER TABLE deliverables ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all access to deliverables" ON deliverables
FOR ALL
USING (true)
WITH CHECK (true);

-- Seed Default Users (Passwords are hashed 'password', 'admin123', 'op123', 'user123')
-- Note: You might need to generate these hashes again if bcrypt rounds differ, but these are from the previous run.
-- Admin: $2b$10$X7... (Example placeholder, I will use the ones generated by the app if I could, but here are standard bcrypt hashes for 'password')
-- Actually, let's just insert them. The app checks bcrypt.compare.

INSERT INTO users (username, password, role, "isActive") VALUES 
('admin', '$2b$10$8.UnT.3.U.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5', 'admin', true), -- Placeholder hash, user needs to run the app to seed properly or I provide a script.
('operator', '$2b$10$8.UnT.3.U.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5', 'operator', true),
('user', '$2b$10$8.UnT.3.U.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5.5', 'user', true)
ON CONFLICT (username) DO NOTHING;

-- WAIT: I cannot easily generate valid bcrypt hashes here without running code. 
-- I will create a separate seed script in Node.js that the user can run, 
-- OR I will update the app to seed if empty, just like before.
